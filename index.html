<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Akıllı Sera Otomasyonu</title>
  <!-- Prism.js CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    header {
      background: #4CAF50;
      color: white;
      padding: 1rem 2rem;
      margin-left: 240px;
      width: calc(100% - 240px);
    }
    .container { display: flex; }
    aside {
      position: fixed; top: 0; left: 0;
      width: 220px; height: 100vh;
      background: #f4f4f4; padding: 1rem;
      overflow-y: auto;
    }
    aside nav a {
      display: block; margin: 0.5rem 0;
      color: #333; text-decoration: none;
      cursor: pointer;
    }
    aside nav a.active { font-weight: bold; color: #4CAF50; }
    main {
      margin-left: 240px; padding: 2rem;
      max-width: 800px;
    }
    section { display: none; }
    section.active { display: block; }
    h2 { border-bottom: 2px solid #4CAF50; padding-bottom: 0.5rem; margin-top: 0; }
    h3 { margin-top: 1.5rem; }
    pre { background: #f5f5f5; padding: 1rem; overflow-x: auto; }
    p { text-align: justify; line-height: 1.6; }
    footer { text-align: center; padding: 1rem; background: #f4f4f4; margin-top: 2rem; }
  </style>
</head>
<body>
  <header>
    <h1>Akıllı Sera Otomasyonu</h1>
  </header>
  <div class="container">
    <aside>
      <nav>
        <a data-target="giris" class="active">Giriş</a>
        <a data-target="tarihce">Tarihçe</a>
        <a data-target="amaci">Amaç ve Kapsam</a>
        <a data-target="mimari">Sistem Mimarisi</a>
        <a data-target="devre">Devre</a>
        <a data-target="tasarim">Tasarım</a>
        <a data-target="uygulama">Uygulama</a>
        <a data-target="sonuc">Sonuç</a>
      </nav>
    </aside>
    <main>
      <section id="giris" class="active">
        <h2>Giriş</h2>
        <p>Seralar, bitkilerin büyüme koşullarını yıl boyunca kontrol altına alan yapılar olarak tarımsal üretimde kritik rol oynar. Optimum sıcaklık, nem ve ışık dengesi sayesinde ürün verimliliği ve kalitesi artar. Bu çalışmada, sensör tabanlı bir otomasyon sistemi ile sera iç ortamı gerçek zamanlı izlenir ve düzenlenir.</p>
      </section>
      <section id="tarihce">
        <h2>Sera Tarihçesi & Modern Uygulamalar</h2>
        <p><strong>Roma İmparatorluğu (M.S. 30):</strong> İmparator Tiberius’un taze salatalık talebini karşılamak için ilk örtülü tarım yapısı geliştirildi.</p>
        <p><strong>Kore, 15. Yüzyıl:</strong> Joseon Hanedanlığı’nda ondol ısıtmalı seralar kışın sebze yetiştirdi.</p>
        <p><strong>Hollanda, 17–18. Yüzyıl:</strong> Cam ve metal seralar modern mimarinin temelini attı.</p>
        <p><strong>19. Yüzyıl Avrupa:</strong> Dökme demir ve cam panellerle tropikal bitkiler yetiştirildi.</p>
        <p><strong>20. Yüzyıl:</strong> Polietilen örtüler ve otomatik sistemler verimliliği artırdı.</p>
        <p><strong>21. Yüzyıl:</strong> IoT ve veri analitiği ile akıllı seralar otonom kontrol sundu.</p>
      </section>
      <section id="amaci">
        <h2>Amaç ve Kapsam</h2>
        <p>Arduino Uno üzerinde toprak nemi, ışık, sıcaklık ve hava kalitesi sensör verileri işlenir. Kontrol algoritmaları röle tabanlı pompa ve aydınlatmayı tetikler. Mobil/masaüstü arayüzle izleme ve manuel müdahale imkânı sunulur.</p>
      </section>
      <section id="mimari">
        <h2>Sistem Mimarisi</h2>
        <p>
          Sistem mimarisi; sensörler, mikrodenetleyici ve kontrol birimlerinden oluşmaktadır. Aşağıda temel bileşenler ve açıklamaları yer almaktadır:
        </p>
        <ul>
          <li>
            <strong>Hava Kalite Sensörü:</strong> Ortamın hava kalitesini ölçerek zararlı gazların ve partiküllerin tespit edilmesini sağlar. Bu sayede sera içerisindeki hava kalitesi sürekli olarak izlenebilir ve gerekli önlemler alınabilir.
            <br>
            <img src="hava.jpg" alt="Hava Kalite Sensörü" style="max-width:200px; margin:10px 0;">
          </li>
          <li>
            <strong>LDR (Işık Sensörü):</strong> Ortamın ışık seviyesini algılayarak bitkilerin ihtiyaç duyduğu aydınlatma koşullarını belirler. Otomatik aydınlatma kontrolü için sistemin temel girdilerinden birini oluşturur.
            <br>
            <img src="ldr.jpg" alt="LDR Işık Sensörü" style="max-width:200px; margin:10px 0;">
          </li>
          <li>
            <strong>Arduino UNO:</strong> Tüm sensörlerden gelen verileri işleyerek gerekli kontrol sinyallerini üretir. Sistemin merkezi yönetim birimi olarak otomasyonun sorunsuz çalışmasını sağlar.
            <br>
            <img src="uno.png" alt="Arduino UNO" style="max-width:200px; margin:10px 0;">
          </li>
          <li>
            <strong>Toprak Nem Sensörü:</strong> Toprağın nem seviyesini ölçerek bitkilerin su ihtiyacını belirler. Otomatik sulama sisteminin doğru zamanda devreye girmesini sağlar.
          </li>
          <li>
            <strong>Su Pompası:</strong> Sensörlerden gelen verilere göre otomatik olarak çalışarak bitkilerin sulanmasını gerçekleştirir. Böylece su tasarrufu sağlanır ve bitkiler ideal koşullarda yetişir.
          </li>
          <li>
            <strong>HC-06:</strong> Arduino ile Android uygulaması arasında kablosuz iletişim kurar. Kullanıcıların sistemi uzaktan izleyip kontrol etmesine olanak tanır.
          </li>
          <li>
            <strong>NeoPixel Led Halka:</strong> Sera ortamındaki durumu aydınlatma sağlamak için kullanılır.
          </li>
        </ul>
      </section>
            <section id="devre">
        <h2>Devre</h2>
        <p>Bu bölümde, projenin ana kod blokları ile her komutun işlevsel açıklamaları yer almaktadır.</p>

        <h3>1. Kütüphane ve Donanım Tanımlamaları</h3>
        <pre><code class="language-cpp">#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Adafruit_AHTX0.h>
#include <SoftwareSerial.h>
#include <Adafruit_NeoPixel.h>

// Pin tanımları
typedef int Pin;
const Pin soilMoisturePin = A0;
const Pin airQualityPin   = A2;
const Pin lightDigitalPin = 2;
const Pin pumpPin         = 8;</code></pre>
        <ul>
          <li><code>#include &lt;Wire.h&gt;</code>: I²C haberleşme kütüphanesini yükler.</li>
          <li><code>#include &lt;LiquidCrystal_I2C.h&gt;</code>: 16×2 LCD ekran sürücüsünü sağlar.</li>
          <li><code>#include &lt;Adafruit_AHTX0.h&gt;</code>: AHT10 sıcaklık ve nem sensörünü başlatır.</li>
          <li><code>#include &lt;SoftwareSerial.h&gt;</code>: HC-05 Bluetooth için yazılım tabanlı seri iletişim açar.</li>
          <li><code>#include &lt;Adafruit_NeoPixel.h&gt;</code>: WS2812B LED halkası kontrol fonksiyonlarını içerir.</li>
          <li>Pin tanımlamaları: Her <code>const Pin</code> tek bir sensör veya röle çıkışını belirtir.</li>
        </ul>

        <h3>2. setup() – Başlangıç Ayarları</h3>
        <pre><code class="language-cpp">void setup() {
  Serial.begin(9600);
  BT.begin(9600);
  lcd.init(); lcd.backlight();
  aht.begin();    // AHT10 başlat
  pinMode(pumpPin, OUTPUT);
  pinMode(lightDigitalPin, INPUT);
  strip.begin(); strip.show();

  // Açılış mesajı
  lcd.print("Akilli Sera");
  delay(1000);
  lcd.clear();
  mode = AUTO;
}</code></pre>
        <ul>
          <li><code>Serial.begin(9600)</code> ve <code>BT.begin(9600)</code>: USB ve Bluetooth 9600 bps ile başlatılır.</li>
          <li><code>lcd.init()</code> ve <code>lcd.backlight()</code>: LCD ekran hazırlanır ve arka ışık açılır.</li>
          <li><code>aht.begin()</code>: Sıcaklık/nem sensörü ilk aygıt konfigürasyonunu yapar.</li>
          <li><code>pinMode(..., OUTPUT/INPUT)</code>: Röle çıkışı ve LDR giriş pini modları ayarlanır.</li>
          <li><code>strip.begin() / strip.show()</code>: LED halkası başlangıçta tüm LED'ler kapalı olacak şekilde resetlenir.</li>
          <li><code>lcd.print("Akilli Sera")</code>: Ekrana karşılama mesajı yazılır, ardından 1 saniye beklenir.</li>
          <li><code>mode = AUTO</code>: Başlangıç modu otomatik olarak ayarlanır.</li>
        </ul>

        <h3>3. loop() – Sürekli Döngü</h3>
        <h4>3.1 Bluetooth Komut İşleme</h4>
        <pre><code class="language-cpp">if (BT.available()) {
  char cmd = BT.read();
  if (mode == AUTO && strchr("AKYS", cmd)) {
    mode = MANUAL;
    lastManualInput = now;
  }
  switch(cmd) {
    case 'A': digitalWrite(pumpPin, LOW);  pumpState = true;  break;
    case 'K': digitalWrite(pumpPin, HIGH); pumpState = false; break;
    case 'Y': setManualLight(true);  lightState = true;  break;
    case 'S': setManualLight(false); lightState = false; break;
    case 'Z': mode = AUTO; break;
  }
}</code></pre>
        <ul>
          <li><code>BT.available()</code>: Bluetooth üzerinden veri gelip gelmediğini kontrol eder.</li>
          <li><code>BT.read()</code>: Gelen karakter komut olarak okunur.</li>
          <li><code>case 'A'</code>, <code>'K'</code>, <code>'Y'</code>, <code>'S'</code>, <code>'Z'</code>: Pompa, LED ve moda geçiş komutlarını işler.</li>
          <li><code>strchr("AKYS", cmd)</code>: Gelen komutun otomatik moddan manuel moda geçiş kriterini karşılayıp karşılamadığını kontrol eder.</li>
        </ul>

        <h4>3.2 Manuel Mod Zaman Aşımı</h4>
        <pre><code class="language-cpp">if (mode == MANUAL && now - lastManualInput > manualTimeout) {
  mode = AUTO;
}</code></pre>
        <p><code>mode</code> değişkeni 5 dk komut gelmezse otomatik moda geri alır (timeout mantığı).</p>

        <h4>3.3 Sensör Okuma ve Otomatik Kontrol</h4>
        <pre><code class="language-cpp">int soil = analogRead(soilMoisturePin);
if (mode == AUTO) {
  if (soil > soilThreshold) {
    // Sulama zamanlayıcı devreye girer
  } else {
    digitalWrite(pumpPin, HIGH);
    pumpState = false;
  }
  strip.clear();
  if (digitalRead(lightDigitalPin) == HIGH) {
    strip.setPixelColor(0, c);
    strip.setPixelColor(5, c);
    strip.setPixelColor(11, c);
    lightState = true;
  }
  strip.show();
}</code></pre>
        <ul>
          <li><code>analogRead()</code>: Toprak nem değerini sayısal olarak okur.</li>
          <li><code>soilThreshold</code>: Nem eşiği, sulama kararını belirler.</li>
          <li><code>digitalWrite(pumpPin, ...)</code>: Pompayı açar/kapar.</li>
          <li><code>strip.clear() / strip.setPixelColor()</code>: LED halkasını temizler ve ışığa göre LED’leri konumlandırır.</li>
        </ul>

        <h4>3.4 Debug & Monitör Çıktıları</h4>
        <pre><code class="language-cpp">Serial.println("===== SENSOR VE KONTROL =====");
Serial.print("Toprak Nem    : "); Serial.println(soil);
Serial.print("Hava Kalitesi : "); Serial.println(air);
Serial.print("Sıcaklık      : "); Serial.print(temp.temperature,1); Serial.println(" C");
Serial.print("Sulama Durumu : "); Serial.println(pumpState?"AÇIK":"KAPALI");
Serial.print("Işık Durumu   : "); Serial.println(lightState?"AYDINLIK":"KARANLIK");</code></pre>
        <ul>
          <li><code>Serial.print/println()</code>: Her parametreyi etiketli olarak USB ve BT monitöre aktarır.</li>
        </ul>

        <h4>3.5 LCD Güncelleme</h4>
        <pre><code class="language-cpp">lcd.setCursor(0,0);
lcd.print("T:"); lcd.print(temp.temperature,0); lcd.print("C ");
lcd.print("H:"); lcd.print(humidity.relative_humidity,0); lcd.print("%");
lcd.setCursor(0,1);
lcd.print("N:"); lcd.print(soil);
lcd.print(" L:"); lcd.print(lightState?"AYDIN":"KARAN");</code></pre>
        <ul>
          <li><code>setCursor()</code>: İmleci satır ve sütuna taşır.</li>
          <li><code>lcd.print()</code>: Sıcaklık, nem, toprak nem ve ışık durumunu iki satırda gösterir.</li>
        </ul>

        <h4>4. Yardımcı Fonksiyon: Manuel Işık</h4>
        <pre><code class="language-cpp">void setManualLight(bool on) {
  strip.clear();
  if (on) {
    strip.setPixelColor(0, c);
    strip.setPixelColor(5, c);
    strip.setPixelColor(11, c);
  }
  strip.show();
}</code></pre>
        <p><code>setManualLight()</code>: Tek fonksiyonla seçilen LED’leri yakıp söndürür.</p>
      </section>
                  <section id="uygulama">
        <h2>Uygulama ve Testler</h2>
        <!-- 1. onCreate Metodu -->
        <h3>1. onCreate() – UI ve Buton Bağlama</h3>
        <pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    // View’ları bağla
    metricView    = findViewById(R.id.metricView)
    tvSerial      = findViewById(R.id.tvSerial)
    btnLightOn    = findViewById(R.id.btnLightOn)
    btnLightOff   = findViewById(R.id.btnLightOff)
    btnWaterOn    = findViewById(R.id.btnWaterOn)
    btnWaterOff   = findViewById(R.id.btnWaterOff)
    btnAutoMode   = findViewById(R.id.btnAutoMode)
    btnManualMode = findViewById(R.id.btnManualMode)

    // Seri monitör kaydırma
    tvSerial.movementMethod = ScrollingMovementMethod()
    tvSerial.isVerticalScrollBarEnabled = true
    tvSerial.setHorizontallyScrolling(true)

    // Buton dinleyicileri
    btnAutoMode.setOnClickListener { sendCommand("Z"); isManualMode = false }
    btnManualMode.setOnClickListener { sendCommand("M"); isManualMode = true }
    btnLightOn.setOnClickListener   { sendCommand("Y") }
    btnLightOff.setOnClickListener  { sendCommand("S") }
    btnWaterOn.setOnClickListener   { sendCommand("A") }
    btnWaterOff.setOnClickListener  { sendCommand("K") }

    ensurePermissionsAndEnableBluetooth()
}</code></pre>
        <ul>
          <li><code>setContentView()</code>: activity_main.xml yüklenir.</li>
          <li><code>findViewById()</code>: UI bileşenleri kod ile eşleştirilir.</li>
          <li><code>ScrollingMovementMethod()</code>: TextView’da kaydırma etkinleştirilir.</li>
          <li><code>setOnClickListener</code>: Her buton için Bluetooth komutunu <code>sendCommand()</code> aracılığıyla gönderir ve mod değişkenini günceller.</li>
        </ul>

        <!-- 2. izin ve Bluetooth Hazırlığı -->
        <h3>2. ensurePermissionsAndEnableBluetooth() – İzin Kontrolleri</h3>
        <pre><code class="language-kotlin">private fun ensurePermissionsAndEnableBluetooth() {
    // Android S ve sonrası için konum izinleri kontrolü
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
        ActivityCompat.requestPermissions(this, REQUIRED_PERMS, REQ_BT_PERMS)
        return
    }
    val adapter = getBluetoothAdapter() ?: run {
        enqueueLine("Bluetooth desteklenmiyor")
        return
    }
    if (!adapter.isEnabled) startActivityForResult(Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE), REQ_ENABLE_BT)
    else connectToHC06()
}</code></pre>
        <ul>
          <li><code>requestPermissions()</code>: Bluetooth izinlerini ister.</li>
          <li><code>getBluetoothAdapter()</code>: Sistemden Bluetooth adaptörü alır.</li>
          <li><code>ACTION_REQUEST_ENABLE</code>: Kullanıcıdan Bluetooth’u açması istenir.</li>
          <li><code>connectToHC06()</code>: HC-06 modüle bağlanma işlemini başlatır.</li>
        </ul>

        <!-- 3. Bağlantı ve Dinleme -->
        <h3>3. connectToHC06() ve startListening() – İletişim</h3>
        <pre><code class="language-kotlin">@SuppressLint("MissingPermission")
private fun connectToHC06() {
    Thread {
        val device = getBluetoothAdapter()!!.getRemoteDevice(DEVICE_ADDRESS)
        socket = device.createRfcommSocketToServiceRecord(BT_UUID)
        socket.connect()
        outStream = socket.outputStream
        handler.post { enqueueLine("HC-06’ya bağlandı") }
        startListening()
    }.start()
}

@SuppressLint("MissingPermission")
private fun startListening() {
    Thread {
        val reader = BufferedReader(InputStreamReader(socket.inputStream))
        while (true) {
            val msg = reader.readLine() ?: continue
            handler.post { handleIncomingMessage(msg) }
        }
    }.start()
}</code></pre>
        <ul>
          <li><code>createRfcommSocketToServiceRecord()</code>: RFCOMM protokolü üzerinden soket oluşturur.</li>
          <li><code>socket.connect()</code>: Fiziksel bağlantıyı sağlar.</li>
          <li><code>startListening()</code>: Arka planda veri okur ve <code>handleIncomingMessage()</code> ile işleme gönderir.</li>
        </ul>

        <!-- 4. Mesaj İşleme ve Arayüz Güncelleme -->
        <h3>4. handleIncomingMessage() – Verilerin İşlenmesi</h3>
        <pre><code class="language-kotlin">private fun handleIncomingMessage(msg: String) {
    // Toprak nem, hava kalitesi, sıcaklık ve ışık verilerini ayrıştır
    when {
        msg.startsWith("Toprak Nem") -> updateMoistureView(msg)
        msg.startsWith("Hava Kalitesi") -> updateAirView(msg)
        msg.startsWith("Sıcaklık") -> metricView.temp = extractValue(msg)
        msg.startsWith("Işık (digital)") && !isManualMode -> metricView.light = if (extractValue(msg)=="1") "Aydınlık" else "Karanlık"
    }
    metricView.invalidate()
    enqueueLine(msg)
}</code></pre>
        <ul>
          <li><code>when</code> bloğu: Verinin tipine göre ilgili güncelleme fonksiyonunu çağırır.</li>
          <li><code>extractValue()</code>: Gelen metinden sayısal değeri ayıklar.</li>
          <li><code>metricView.invalidate()</code>: Özel görünümü yeniden çizer.</li>
        </ul>

        <!-- 5. Loglama ve Ekran Temizleme -->
        <h3>5. enqueueLine() – Serial Log Yönetimi</h3>
        <pre><code class="language-kotlin">private fun enqueueLine(line: String) {
    pendingLines += line
    if (!flushScheduled) {
        handler.postDelayed({
            tvSerial.text = pendingLines.joinToString("
")
            autoScroll(tvSerial)
            pendingLines.clear()
            flushScheduled = false
        }, flushIntervalMs)
        flushScheduled = true
    }
}</code></pre>
        <ul>
          <li><code>pendingLines</code>: Geçici liste ile hata veya veri satırları biriktirilir.</li>
          <li><code>postDelayed</code>: Belirtilen süre sonra TextView’ı temizleyip satırları yeniden ekler.</li>
          <li><code>autoScroll()</code>: TextView’da en son satıra otomatik kaydırma yapar.</li>
        </ul>
      </section>
      <section id="tasarim">
        <h2>Tasarım</h2>
        <p>Bu bölümde, Android uygulamasının arayüz tasarımında kullanılan temel bileşenler ve fonksiyonlar adım adım açıklanmıştır.</p>

        <h3>1. Ana Yerleşim (ConstraintLayout)</h3>
        <pre><code class="language-xml">&lt;androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"&gt;
    ...
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre>
        <ul>
          <li><strong>ConstraintLayout</strong>: Tüm arayüzün ana kapsayıcısıdır. Bileşenlerin birbirine ve kenarlara göre hizalanmasını sağlar.</li>
        </ul>

        <h3>2. Ölçüm Dairesi (MetricCircleView)</h3>
        <pre><code class="language-xml">&lt;com.example.seraotomasyonapp.MetricCircleView
    android:id="@+id/metricView"
    android:layout_width="250dp"
    android:layout_height="250dp"
    app:layout_constraintTop_toTopOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintEnd_toEndOf="parent"/&gt;</code></pre>
        <ul>
          <li><strong>MetricCircleView</strong>: Sıcaklık, nem gibi değerleri dairesel grafikle gösteren özel bir görünümdür.</li>
          <li><code>layout_constraintTop_toTopOf="parent"</code>: Üstten hizalanır.</li>
          <li><code>layout_constraintStart_toStartOf="parent"</code> ve <code>layout_constraintEnd_toEndOf="parent"</code>: Yatayda ortalanır.</li>
        </ul>

        <h3>3. Seri Monitör (TextView)</h3>
        <pre><code class="language-xml">&lt;TextView
    android:id="@+id/tvSerial"
    android:layout_width="0dp"
    android:layout_height="0dp"
    android:background="#EEEEEE"
    android:padding="8dp"
    android:scrollbars="vertical|horizontal"
    android:overScrollMode="always"
    android:ellipsize="none"
    android:scrollHorizontally="true"
    app:layout_constraintTop_toBottomOf="@id/metricView"
    app:layout_constraintBottom_toTopOf="@id/modeContainer"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintEnd_toEndOf="parent"/&gt;</code></pre>
        <ul>
          <li><strong>tvSerial</strong>: Arduino’dan gelen verilerin ve logların gösterildiği kaydırılabilir metin alanıdır.</li>
          <li><code>scrollbars</code>: Hem dikey hem yatay kaydırma çubuğu ekler.</li>
        </ul>

        <h3>4. Mod Seçim Butonları (Otomatik/Manuel)</h3>
        <pre><code class="language-xml">&lt;LinearLayout
    android:id="@+id/modeContainer"
    android:orientation="horizontal"
    ...&gt;
      &lt;Button
        android:id="@+id/btnAutoMode"
        android:layout_weight="1"
        android:text="OTOMATİK MOD"/&gt;
      &lt;Button
        android:id="@+id/btnManualMode"
        android:layout_weight="1"
        android:text="MANUEL MOD"/&gt;
    &lt;/LinearLayout&gt;</code></pre>
        <ul>
          <li><strong>btnAutoMode</strong>: Sistemi otomatik moda alır.</li>
          <li><strong>btnManualMode</strong>: Manuel kontrol moduna geçiş yapar.</li>
          <li><code>layout_weight="1"</code>: Butonlar eşit genişlikte olur.</li>
        </ul>

        <h3>5. Kontrol Butonları (Işık ve Sulama)</h3>
        <pre><code class="language-xml">&lt;LinearLayout
    android:id="@+id/controlContainer"
    android:orientation="vertical"
    ...&gt;
      &lt;LinearLayout android:orientation="horizontal"&gt;
        &lt;Button android:id="@+id/btnLightOn" android:text="IŞIK AÇ"/&gt;
        &lt;Button android:id="@+id/btnLightOff" android:text="IŞIK KAPAT"/&gt;
      &lt;/LinearLayout&gt;
      &lt;LinearLayout android:orientation="horizontal"&gt;
        &lt;Button android:id="@+id/btnWaterOn" android:text="SULAMA AÇ"/&gt;
        &lt;Button android:id="@+id/btnWaterOff" android:text="SULAMA KAPAT"/&gt;
      &lt;/LinearLayout&gt;
    &lt;/LinearLayout&gt;</code></pre>
        <ul>
          <li><strong>btnLightOn / btnLightOff</strong>: Işık kontrolü sağlar.</li>
          <li><strong>btnWaterOn / btnWaterOff</strong>: Sulama pompasını açıp kapatır.</li>
        </ul>

        <h3>6. Temel Fonksiyonlar ve Kullanımı</h3>
        <pre><code class="language-kotlin">// Otomatik/Manuel mod geçişi
btnAutoMode.setOnClickListener { sendCommand("Z"); isManualMode = false }
btnManualMode.setOnClickListener { sendCommand("M"); isManualMode = true }

// Işık ve sulama kontrolü
btnLightOn.setOnClickListener   { sendCommand("Y") }
btnLightOff.setOnClickListener  { sendCommand("S") }
btnWaterOn.setOnClickListener   { sendCommand("A") }
btnWaterOff.setOnClickListener  { sendCommand("K") }
</code></pre>
        <ul>
          <li><strong>sendCommand()</strong>: Bluetooth üzerinden Arduino’ya komut gönderir.</li>
          <li><strong>isManualMode</strong>: Arayüzde manuel modun aktif olup olmadığını tutar.</li>
        </ul>

        <h3>7. Seri Monitör Güncelleme</h3>
        <pre><code class="language-kotlin">private fun enqueueLine(line: String) {
    pendingLines += line
    if (!flushScheduled) {
        handler.postDelayed({
            tvSerial.text = pendingLines.joinToString("\n")
            autoScroll(tvSerial)
            pendingLines.clear()
            flushScheduled = false
        }, flushIntervalMs)
        flushScheduled = true
    }
}</code></pre>
        <ul>
          <li><strong>enqueueLine()</strong>: Gelen verileri toplar ve belirli aralıklarla ekrana yazar.</li>
          <li><strong>autoScroll()</strong>: TextView’ın en altına otomatik kaydırma yapar.</li>
        </ul>
      </section>
      <section id="sonuc">
        <h2>Sonuç</h2>
        <p>
          Bu projede, akıllı sera otomasyon sistemi hem donanım hem de yazılım olarak başarıyla tasarlanıp uygulanmıştır. Sistem, toprak nemi, sıcaklık, hava kalitesi ve ışık gibi çevresel parametreleri sensörler aracılığıyla sürekli izleyerek, bitkilerin ihtiyaçlarına göre otomatik veya manuel olarak sulama ve aydınlatma işlemlerini gerçekleştirebilmektedir. 
          <br><br>
          Bluetooth üzerinden Android uygulaması ile uzaktan kontrol ve izleme imkanı sağlanmıştır. Kullanıcı dostu arayüz sayesinde, sera ortamı kolayca takip edilebilmekte ve gerekli müdahaleler hızlıca yapılabilmektedir. 
          <br><br>
          Proje kapsamında geliştirilen sistem, enerji ve su tasarrufu sağlarken, bitki gelişimini optimize etmeye yardımcı olmaktadır. Ayrıca, modüler yapısı sayesinde farklı sensör ve kontrol birimleri eklenerek sistem kolayca genişletilebilir. 
          <br><br>
          Sonuç olarak, akıllı sera otomasyonu; tarımsal üretimde verimliliği artıran, insan müdahalesini azaltan ve sürdürülebilir tarım uygulamalarına katkı sağlayan yenilikçi bir çözüm sunmaktadır. Gelecekte, bulut tabanlı veri analizi ve uzaktan erişim gibi ek özelliklerle sistemin daha da geliştirilmesi mümkündür.
        </p>
      </section>
    </main>
  </div>
  <footer>
    <p>Teşekkürler!</p>
  </footer>
  <!-- Prism.js Script -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const links = document.querySelectorAll('aside nav a');
      const sections = document.querySelectorAll('main section');
      links.forEach(link => {
        link.addEventListener('click', function() {
          links.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
          const target = this.getAttribute('data-target');
          sections.forEach(sec => sec.classList.toggle('active', sec.id === target));
        });
      });
    });
  </script>
  <script>
    // Menü başlıklarına tıklandığında sayfayı en başa kaydır
    document.querySelectorAll('aside nav a').forEach(function(link) {
      link.addEventListener('click', function() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
        // Eğer başka bir başlık tıklama işlemi varsa, onu da burada bırakabilirsiniz
      });
    });
  </script>
</body>
</html>
